name: CI / example

on:
  push:
  pull_request:

jobs:
  integration-test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: "go.mod"
          cache: true

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "yarn"
          cache-dependency-path: "example/yarn.lock"

      - name: Enable Corepack
        run: corepack enable

      - name: Get current date for apt cache
        id: date
        run: echo "date=$(date +%Y-%m-%d)" >> $GITHUB_OUTPUT

      - name: Cache apt packages
        uses: actions/cache@v4
        with:
          path: |
            ~/.apt-cache
          key: ${{ runner.os }}-apt-protobuf-${{ steps.date.outputs.date }}
          restore-keys: |
            ${{ runner.os }}-apt-protobuf-

      - name: Install Protocol Buffers
        run: |
          # Create cache directory
          mkdir -p ~/.apt-cache

          # Check if protoc is already cached
          if [ -f ~/.apt-cache/protoc ]; then
            echo "Using cached protoc"
            sudo cp ~/.apt-cache/protoc /usr/local/bin/protoc
            sudo chmod +x /usr/local/bin/protoc
          else
            echo "Installing protoc and caching it"
            sudo apt-get update
            sudo apt-get install -y protobuf-compiler
            # Cache the binary
            cp /usr/bin/protoc ~/.apt-cache/protoc
          fi

          # Verify installation
          protoc --version

      - name: Install Go dependencies
        run: go mod download

      - name: Install Go protobuf plugins
        run: |
          go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.35.2
          go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.5.1

      - name: Install yarn dependencies
        run: |
          cd example
          yarn install --frozen-lockfile

      - name: Generate protobuf files
        run: |
          cd example
          make test.pb.go

      - name: Start Go server in background
        run: |
          cd example
          make rungo &
          echo $! > server.pid
          echo "Started server with PID: $(cat server.pid)"

      - name: Wait for server to be ready
        run: |
          cd example
          echo "Waiting for server to start..."
          for i in {1..30}; do
            if ss -tuln | grep -q :8080; then
              echo "Server is ready!"
              break
            fi
            if [ $i -eq 30 ]; then
              echo "Server failed to start within 30 seconds"
              if [ -f server.pid ]; then
                echo "Server PID: $(cat server.pid)"
                ps aux | grep $(cat server.pid) || echo "Server process not found"
              fi
              exit 1
            fi
            echo "Attempt $i/30: Server not ready yet, waiting..."
            sleep 1
          done

      - name: Run TypeScript client test
        run: |
          cd example
          echo "Running TypeScript client tests..."
          timeout 60 make runjs

      - name: Show server logs (if failure)
        if: failure()
        run: |
          cd example
          if [ -f server.pid ]; then
            echo "Server PID: $(cat server.pid)"
            ps aux | grep $(cat server.pid) || echo "Server process not found"
          fi
          echo "Checking if port 8080 is still in use:"
          ss -tuln | grep :8080 || echo "Port 8080 not in use"

      - name: Stop Go server
        run: |
          cd example
          if [ -f server.pid ]; then
            PID=$(cat server.pid)
            echo "Stopping server with PID: $PID"
            kill $PID 2>/dev/null || echo "Process $PID already stopped"
            # Wait for graceful shutdown
            for i in {1..10}; do
              if ! kill -0 $PID 2>/dev/null; then
                echo "Server stopped gracefully"
                break
              fi
              sleep 1
            done
            # Force kill if still running
            kill -9 $PID 2>/dev/null || echo "Process $PID already stopped"
            rm -f server.pid
          fi
          # Kill any remaining processes on port 8080
          pkill -f "go run examplemain/main.go" || echo "No remaining processes found"
          echo "Cleanup completed"
        if: always()
